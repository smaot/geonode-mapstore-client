(self.webpackChunkgeonode_mapstore_client=self.webpackChunkgeonode_mapstore_client||[]).push([[1577],{701577:(e,t,i)=>{"use strict";i.d(t,{Z:()=>V});var n=i(378426),s=i(919629),r=i(9520),o=i(173381),h=i(623068),a=i(30006),g=i(752043),l=i(938024),d=i(273101),u=i(925753),c=i(473392),_=i(973410),f=i(436403),m=i(421915),p=i(690728),y=i(831219),x=i(179682),v=i(15265),C=i(218672),S=i(949179);const F=[0,0,0,0],P=[],E="modifyend";class M extends r.ZP{constructor(e,t,i){super(e),this.features=t,this.mapBrowserEvent=i}}class w extends l.Z{constructor(e){let t;if(super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:f.Xp,this.defaultDeleteCondition_=function(e){return(0,f.Ko)(e)&&(0,f.Kf)(e)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:f.Bx,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new d.Z,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new c.Z({source:new _.Z({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:b(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null,e.features?t=e.features:e.source&&(this.source_=e.source,t=new n.Z(this.source_.getFeatures()),this.source_.addEventListener(u.Z.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(u.Z.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(s.Z.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(s.Z.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=void 0===e.snapToPointer?!this.hitDetection_:e.snapToPointer}addFeature_(e){const t=e.getGeometry();if(t){const i=this.SEGMENT_WRITERS_[t.getType()];i&&i(e,t)}const i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,i),e.addEventListener(o.Z.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new n.Z;const i=this.featuresBeingModified_.getArray();for(let e=0,n=t.length;e<n;++e){const n=t[e];for(let e=0,t=n.length;e<t;++e){const t=n[e].feature;t&&!i.includes(t)&&this.featuresBeingModified_.push(t)}}0===this.featuresBeingModified_.getLength()?this.featuresBeingModified_=null:this.dispatchEvent(new M("modifystart",this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(o.Z.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,i=[];t.forEach((function(t){e===t.feature&&i.push(t)}));for(let e=i.length-1;e>=0;--e){const n=i[e];for(let e=this.dragSegments_.length-1;e>=0;--e)this.dragSegments_[e][0]===n&&this.dragSegments_.splice(e,1);t.remove(n)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const i=t.getCoordinates(),n={feature:e,geometry:t,segment:[i,i]};this.rBush_.insert(t.getExtent(),n)}writeMultiPointGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length;n<s;++n){const s=i[n],r={feature:e,geometry:t,depth:[n],index:n,segment:[s,s]};this.rBush_.insert(t.getExtent(),r)}}writeLineStringGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length-1;n<s;++n){const s=i.slice(n,n+2),r={feature:e,geometry:t,index:n,segment:s};this.rBush_.insert((0,m.hI)(s),r)}}writeMultiLineStringGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length;n<s;++n){const s=i[n];for(let i=0,r=s.length-1;i<r;++i){const r=s.slice(i,i+2),o={feature:e,geometry:t,depth:[n],index:i,segment:r};this.rBush_.insert((0,m.hI)(r),o)}}}writePolygonGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length;n<s;++n){const s=i[n];for(let i=0,r=s.length-1;i<r;++i){const r=s.slice(i,i+2),o={feature:e,geometry:t,depth:[n],index:i,segment:r};this.rBush_.insert((0,m.hI)(r),o)}}}writeMultiPolygonGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length;n<s;++n){const s=i[n];for(let i=0,r=s.length;i<r;++i){const r=s[i];for(let s=0,o=r.length-1;s<o;++s){const o=r.slice(s,s+2),h={feature:e,geometry:t,depth:[i,n],index:s,segment:o};this.rBush_.insert((0,m.hI)(o),h)}}}}writeCircleGeometry_(e,t){const i=t.getCenter(),n={feature:e,geometry:t,index:0,segment:[i,i]},s={feature:e,geometry:t,index:1,segment:[i,i]},r=[n,s];n.featureSegments=r,s.featureSegments=r,this.rBush_.insert((0,m.HK)(i),n);let o=t;const h=(0,C.Cs)();if(h&&this.getMap()){const e=this.getMap().getView().getProjection();o=o.clone().transform(h,e),o=(0,v.Bb)(o).transform(e,h)}this.rBush_.insert(o.getExtent(),s)}writeGeometryCollectionGeometry_(e,t){const i=t.getGeometriesArray();for(let t=0;t<i.length;++t){const n=i[t];(0,this.SEGMENT_WRITERS_[n.getType()])(e,n)}}createOrUpdateVertexFeature_(e,t,i){let n=this.vertexFeature_;return n?n.getGeometry().setCoordinates(e):(n=new h.Z(new g.Z(e)),this.vertexFeature_=n,this.overlay_.getSource().addFeature(n)),n.set("features",t),n.set("geometries",i),n}handleEvent(e){if(!e.originalEvent)return!0;let t;return this.lastPointerEvent_=e,e.map.getView().getInteracting()||e.type!=a.Z.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(t=!(e.type!=a.Z.SINGLECLICK||!this.ignoreNextSingleClick_)||this.removePoint()),e.type==a.Z.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_);const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],i=[],n=[];for(let s=0,r=this.dragSegments_.length;s<r;++s){const r=this.dragSegments_[s],o=r[0],h=o.feature;i.includes(h)||i.push(h);const a=o.geometry;n.includes(a)||n.push(a);const g=o.depth;let l;const d=o.segment,u=r[1];for(;t.length<a.getStride();)t.push(d[u][t.length]);switch(a.getType()){case"Point":l=t,d[0]=t,d[1]=t;break;case"MultiPoint":l=a.getCoordinates(),l[o.index]=t,d[0]=t,d[1]=t;break;case"LineString":l=a.getCoordinates(),l[o.index+u]=t,d[u]=t;break;case"MultiLineString":case"Polygon":l=a.getCoordinates(),l[g[0]][o.index+u]=t,d[u]=t;break;case"MultiPolygon":l=a.getCoordinates(),l[g[1]][g[0]][o.index+u]=t,d[u]=t;break;case"Circle":if(d[0]=t,d[1]=t,0===o.index)this.changingFeature_=!0,a.setCenter(t),this.changingFeature_=!1;else{this.changingFeature_=!0;const i=e.map.getView().getProjection();let n=(0,p.TE)((0,C.Vs)(a.getCenter(),i),(0,C.Vs)(t,i));const s=(0,C.Cs)();if(s){const e=a.clone().transform(s,i);e.setRadius(n),n=e.transform(i,s).getRadius()}a.setRadius(n),this.changingFeature_=!1}}l&&this.setGeometryCoordinates_(a,l)}this.createOrUpdateVertexFeature_(t,i,n)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate;this.handlePointerAtPixel_(e.pixel,e.map,t),this.dragSegments_.length=0,this.featuresBeingModified_=null;const i=this.vertexFeature_;if(i){const n=e.map.getView().getProjection(),s=[],r=i.getGeometry().getCoordinates(),o=(0,m.hI)([r]),h=this.rBush_.getInExtent(o),a={};h.sort(B);for(let i=0,o=h.length;i<o;++i){const o=h[i],g=o.segment;let l=(0,S.sq)(o.geometry);const d=o.depth;if(d&&(l+="-"+d.join("-")),a[l]||(a[l]=new Array(2)),"Circle"!==o.geometry.getType()||1!==o.index)if(!(0,p.fS)(g[0],r)||a[l][0])if(!(0,p.fS)(g[1],r)||a[l][1])(0,S.sq)(g)in this.vertexSegments_&&!a[l][0]&&!a[l][1]&&this.insertVertexCondition_(e)&&s.push(o);else{if(a[l][0]&&0===a[l][0].index){let e=o.geometry.getCoordinates();switch(o.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":e=e[d[1]];case"Polygon":if(o.index!==e[d[0]].length-2)continue}}this.dragSegments_.push([o,1]),a[l][1]=o}else this.dragSegments_.push([o,0]),a[l][0]=o;else{const e=G(t,o,n);(0,p.fS)(e,r)&&!a[l][0]&&(this.dragSegments_.push([o,0]),a[l][0]=o)}}s.length&&this.willModifyFeatures_(e,[s]);for(let e=s.length-1;e>=0;--e)this.insertVertex_(s[e],r)}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const i=this.dragSegments_[t][0],n=i.geometry;if("Circle"===n.getType()){const t=n.getCenter(),s=i.featureSegments[0],r=i.featureSegments[1];s.segment[0]=t,s.segment[1]=t,r.segment[0]=t,r.segment[1]=t,this.rBush_.update((0,m.HK)(t),s);let o=n;const h=(0,C.Cs)();if(h){const t=e.map.getView().getProjection();o=o.clone().transform(h,t),o=(0,v.Bb)(o).transform(t,h)}this.rBush_.update(o.getExtent(),r)}else this.rBush_.update((0,m.hI)(i.segment),i)}return this.featuresBeingModified_&&(this.dispatchEvent(new M(E,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.pixel,e.map,e.coordinate)}handlePointerAtPixel_(e,t,i){const n=i||t.getCoordinateFromPixel(e),s=t.getView().getProjection(),r=function(e,t){return T(n,e,s)-T(n,t,s)};let o,a;if(this.hitDetection_){const i="object"==typeof this.hitDetection_?e=>e===this.hitDetection_:void 0;t.forEachFeatureAtPixel(e,((e,t,i)=>{i&&(i=new g.Z((0,C.lO)(i.getCoordinates(),s)));const n=i||e.getGeometry();if("Point"===n.getType()&&e instanceof h.Z&&this.features_.getArray().includes(e)){a=n;const t=e.getGeometry().getFlatCoordinates().slice(0,2);o=[{feature:e,geometry:a,segment:[t,t]}]}return!0}),{layerFilter:i})}if(!o){const e=(0,C.dY)((0,m.HK)(n,F),s),i=t.getView().getResolution()*this.pixelTolerance_,r=(0,C.Fj)((0,m.f3)(e,i,F),s);o=this.rBush_.getInExtent(r)}if(o&&o.length>0){const i=o.sort(r)[0],h=i.segment;let g=G(n,i,s);const l=t.getPixelFromCoordinate(g);let d=(0,p.TE)(e,l);if(a||d<=this.pixelTolerance_){const e={};if(e[(0,S.sq)(h)]=!0,this.snapToPointer_||(this.delta_[0]=g[0]-n[0],this.delta_[1]=g[1]-n[1]),"Circle"===i.geometry.getType()&&1===i.index)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(g,[i.feature],[i.geometry]);else{const n=t.getPixelFromCoordinate(h[0]),s=t.getPixelFromCoordinate(h[1]),r=(0,p.bI)(l,n),a=(0,p.bI)(l,s);d=Math.sqrt(Math.min(r,a)),this.snappedToVertex_=d<=this.pixelTolerance_,this.snappedToVertex_&&(g=r>a?h[1]:h[0]),this.createOrUpdateVertexFeature_(g,[i.feature],[i.geometry]);const u={};u[(0,S.sq)(i.geometry)]=!0;for(let t=1,i=o.length;t<i;++t){const i=o[t].segment;if(!((0,p.fS)(h[0],i[0])&&(0,p.fS)(h[1],i[1])||(0,p.fS)(h[0],i[1])&&(0,p.fS)(h[1],i[0])))break;{const n=(0,S.sq)(o[t].geometry);n in u||(u[n]=!0,e[(0,S.sq)(i)]=!0)}}}return void(this.vertexSegments_=e)}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const i=e.segment,n=e.feature,s=e.geometry,r=e.depth,o=e.index;let h;for(;t.length<s.getStride();)t.push(0);switch(s.getType()){case"MultiLineString":case"Polygon":h=s.getCoordinates(),h[r[0]].splice(o+1,0,t);break;case"MultiPolygon":h=s.getCoordinates(),h[r[1]][r[0]].splice(o+1,0,t);break;case"LineString":h=s.getCoordinates(),h.splice(o+1,0,t);break;default:return}this.setGeometryCoordinates_(s,h);const a=this.rBush_;a.remove(e),this.updateSegmentIndices_(s,o,r,1);const g={segment:[i[0],t],feature:n,geometry:s,depth:r,index:o};a.insert((0,m.hI)(g.segment),g),this.dragSegments_.push([g,1]);const l={segment:[t,i[1]],feature:n,geometry:s,depth:r,index:o+1};a.insert((0,m.hI)(l.segment),l),this.dragSegments_.push([l,0]),this.ignoreNextSingleClick_=!0}removePoint(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=a.Z.POINTERDRAG){const e=this.lastPointerEvent_;this.willModifyFeatures_(e,this.dragSegments_);const t=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new M(E,this.featuresBeingModified_,e)),this.featuresBeingModified_=null,t}return!1}removeVertex_(){const e=this.dragSegments_,t={};let i,n,s,r,o,h,a,g,l,d,u,c=!1;for(o=e.length-1;o>=0;--o)s=e[o],d=s[0],u=(0,S.sq)(d.feature),d.depth&&(u+="-"+d.depth.join("-")),u in t||(t[u]={}),0===s[1]?(t[u].right=d,t[u].index=d.index):1==s[1]&&(t[u].left=d,t[u].index=d.index+1);for(u in t){switch(l=t[u].right,a=t[u].left,h=t[u].index,g=h-1,d=void 0!==a?a:l,g<0&&(g=0),r=d.geometry,n=r.getCoordinates(),i=n,c=!1,r.getType()){case"MultiLineString":n[d.depth[0]].length>2&&(n[d.depth[0]].splice(h,1),c=!0);break;case"LineString":n.length>2&&(n.splice(h,1),c=!0);break;case"MultiPolygon":i=i[d.depth[1]];case"Polygon":i=i[d.depth[0]],i.length>4&&(h==i.length-1&&(h=0),i.splice(h,1),c=!0,0===h&&(i.pop(),i.push(i[0]),g=i.length-1))}if(c){this.setGeometryCoordinates_(r,n);const t=[];if(void 0!==a&&(this.rBush_.remove(a),t.push(a.segment[0])),void 0!==l&&(this.rBush_.remove(l),t.push(l.segment[1])),void 0!==a&&void 0!==l){const e={depth:d.depth,feature:d.feature,geometry:d.geometry,index:g,segment:t};this.rBush_.insert((0,m.hI)(e.segment),e)}this.updateSegmentIndices_(r,h,d.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return c}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,i,n){this.rBush_.forEachInExtent(e.getExtent(),(function(s){s.geometry===e&&(void 0===i||void 0===s.depth||(0,x.fS)(s.depth,i))&&s.index>t&&(s.index+=n)}))}}function B(e,t){return e.index-t.index}function T(e,t,i){const n=t.geometry;if("Circle"===n.getType()){let s=n;if(1===t.index){const t=(0,C.Cs)();t&&(s=s.clone().transform(t,i));const n=(0,p.bI)(s.getCenter(),(0,C.Vs)(e,i)),r=Math.sqrt(n)-s.getRadius();return r*r}}const s=(0,C.Vs)(e,i);return P[0]=(0,C.Vs)(t.segment[0],i),P[1]=(0,C.Vs)(t.segment[1],i),(0,p.Bs)(s,P)}function G(e,t,i){const n=t.geometry;if("Circle"===n.getType()&&1===t.index){let t=n;const s=(0,C.Cs)();return s&&(t=t.clone().transform(s,i)),(0,C.lO)(t.getClosestPoint((0,C.Vs)(e,i)),i)}const s=(0,C.Vs)(e,i);return P[0]=(0,C.Vs)(t.segment[0],i),P[1]=(0,C.Vs)(t.segment[1],i),(0,C.lO)((0,p.oL)(s,P),i)}function b(){const e=(0,y.Ly)();return function(t,i){return e.Point}}const V=w}}]);